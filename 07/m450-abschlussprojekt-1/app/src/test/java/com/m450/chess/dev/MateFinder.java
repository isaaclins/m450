package com.m450.chess.dev;

import com.m450.chess.engine.Board;
import com.m450.chess.engine.Color;
import com.m450.chess.engine.Piece;
import com.m450.chess.engine.Position;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public final class MateFinder {
    private static final int MAX_PLIES = 9; // increase if needed
    private static final int BRANCH_LIMIT = 24;

    public static void main(String[] args) {
        SearchResult result = findAnyMateLine(Board.initialSetup(), MAX_PLIES);
        if (result == null) {
            System.out.println(
                    "No mate line found within " + MAX_PLIES + " plies (with branch limit " + BRANCH_LIMIT + ").");
            System.exit(2);
            return;
        }

        int whiteMovesToMate = (result.pliesToMate + 1) / 2;
        System.out.println("Found mate in " + whiteMovesToMate + " (plies=" + result.pliesToMate + ")");
        for (Move m : result.line) {
            System.out.println(m.from.toAlgebraic() + " " + m.to.toAlgebraic());
        }

        Path out = resolveRepoRelative(Path.of("scripts/mate-asap.txt"));
        try {
            Files.createDirectories(out.getParent());
            Files.writeString(out, toScript(result, whiteMovesToMate));
            System.out.println("Wrote: " + out);
        } catch (IOException e) {
            System.out.println("Failed to write script: " + e.getMessage());
            System.exit(3);
        }
    }

    private static String toScript(SearchResult result, int mateIn) {
        StringBuilder sb = new StringBuilder();
        sb.append("# Auto-generated by MateFinder\n");
        sb.append("# Mate in ").append(mateIn).append(" (not necessarily forced)\n\n");
        for (Move m : result.line) {
            sb.append(m.from.toAlgebraic()).append(' ').append(m.to.toAlgebraic()).append('\n');
        }
        return sb.toString();
    }

    private static SearchResult findAnyMateLine(Board start, int maxPlies) {
        for (int depth = 1; depth <= maxPlies; depth++) {
            SearchResult r = dfs(start, depth, new ArrayList<>(), new HashSet<>());
            if (r != null) {
                return r;
            }
        }
        return null;
    }

    private static SearchResult dfs(Board board, int remainingPlies, List<Move> prefix, Set<String> pathSignatures) {
        String sig = signature(board);
        if (!pathSignatures.add(sig)) {
            return null;
        }

        try {
            // If side to move is checkmated, previous move delivered mate.
            Color sideToMove = board.currentPlayer();
            if (board.isCheckmate(sideToMove)) {
                if (!prefix.isEmpty()) {
                    Color winner = (sideToMove == Color.WHITE) ? Color.BLACK : Color.WHITE;
                    if (winner == Color.WHITE) {
                        return new SearchResult(new ArrayList<>(prefix), prefix.size());
                    }
                }
                return null;
            }

            if (remainingPlies == 0) {
                return null;
            }

            List<Move> moves = generateMoves(board);
            moves.sort(Comparator.comparingInt(m -> -scoreMove(board, m)));
            if (moves.size() > BRANCH_LIMIT) {
                moves = moves.subList(0, BRANCH_LIMIT);
            }

            for (Move m : moves) {
                Board next = snapshot(board);
                if (!next.move(m.from, m.to)) {
                    continue;
                }
                prefix.add(m);
                SearchResult r = dfs(next, remainingPlies - 1, prefix, pathSignatures);
                if (r != null) {
                    return r;
                }
                prefix.remove(prefix.size() - 1);
            }

            return null;
        } finally {
            pathSignatures.remove(sig);
        }
    }

    private static int scoreMove(Board board, Move m) {
        // Cheap heuristics: checks > captures > queen moves > everything else
        int score = 0;

        Piece captured = board.pieceAt(m.to);
        if (captured != null) {
            score += 50;
        }

        Board next = snapshot(board);
        if (next.move(m.from, m.to)) {
            Color opponent = next.currentPlayer();
            if (next.isCheckmate(opponent)) {
                score += 1_000_000;
            } else if (next.isKingInCheck(opponent)) {
                score += 200;
            }
        }

        Piece moving = board.pieceAt(m.from);
        if (moving != null && moving.type().name().equals("QUEEN")) {
            score += 10;
        }

        return score;
    }

    private static List<Move> generateMoves(Board board) {
        List<Move> moves = new ArrayList<>();
        Color side = board.currentPlayer();
        for (int f = 0; f < 10; f++) {
            for (int r = 0; r < 10; r++) {
                Position from = Position.of(f, r);
                Piece p = board.pieceAt(from);
                if (p == null || p.color() != side) {
                    continue;
                }
                for (int tf = 0; tf < 10; tf++) {
                    for (int tr = 0; tr < 10; tr++) {
                        Position to = Position.of(tf, tr);
                        if (board.isLegalMove(from, to)) {
                            moves.add(new Move(from, to));
                        }
                    }
                }
            }
        }
        return moves;
    }

    private static Board snapshot(Board board) {
        // Rebuild board from the public surface (preserves moved flags).
        java.util.Map<Position, Piece> map = new java.util.HashMap<>();
        for (int f = 0; f < 10; f++) {
            for (int r = 0; r < 10; r++) {
                Position pos = Position.of(f, r);
                Piece p = board.pieceAt(pos);
                if (p != null) {
                    map.put(pos, p);
                }
            }
        }
        return new Board(map, board.currentPlayer());
    }

    private static String signature(Board board) {
        StringBuilder sb = new StringBuilder(100 * 4);
        sb.append(board.currentPlayer().name()).append('|');
        for (int r = 0; r < 10; r++) {
            for (int f = 0; f < 10; f++) {
                Position pos = Position.of(f, r);
                Piece p = board.pieceAt(pos);
                if (p == null) {
                    sb.append("..;");
                } else {
                    sb.append(p.color().name().charAt(0));
                    sb.append(p.type().name().charAt(0));
                    sb.append(p.moved() ? '1' : '0');
                    sb.append(';');
                }
            }
        }
        return sb.toString();
    }

    private static Path resolveRepoRelative(Path relative) {
        if (relative.isAbsolute()) {
            return relative;
        }

        Path base = Path.of(System.getProperty("user.dir"));
        Path cursor = base;
        for (int i = 0; i < 4; i++) {
            Path candidate = cursor.resolve(relative).normalize();
            // If the repo has a scripts/ folder, this is likely the root.
            if (Files.exists(cursor.resolve("scripts")) || Files.exists(candidate)) {
                return candidate;
            }
            cursor = cursor.getParent();
            if (cursor == null) {
                break;
            }
        }
        return base.resolve(relative).normalize();
    }

    private record Move(Position from, Position to) {
    }

    private record SearchResult(List<Move> line, int pliesToMate) {
    }
}
